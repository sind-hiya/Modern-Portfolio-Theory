import numpy as np
import matplotlib.pyplot as plt
from numpy import random
import pandas as pd
from pandas.core.frame import DataFrame
import requests
from alpha_vantage.timeseries import TimeSeries
import math
API_key = 'TSX9611IFPXD1536'
ts = TimeSeries(key = API_key, output_format='pandas')

def create_returns_list(symbol_array):
    returns_array = []
    min_length = math. inf
    for i in range(len(symbol_array)):
        monthly_adjusted = ts.get_monthly_adjusted(symbol_array[i])
        data = monthly_adjusted[0]
        monthly_adjusted_close = data['5. adjusted close']
        if len(monthly_adjusted_close) < min_length:
            min_length = len(monthly_adjusted_close)
    for i in range(len(symbol_array)):
        monthly_adjusted = ts.get_monthly_adjusted(symbol_array[i])
        data = monthly_adjusted[0]
        monthly_adjusted_close = data['5. adjusted close']
        correct_length_array = []
        returns = []
        for j in range(len(monthly_adjusted_close) - min_length, len(monthly_adjusted_close)):
            correct_length_array = monthly_adjusted_close.iloc[j]
        for j in range(0, ((len(correct_length_array)-1)//12)):
            returns.append(100*(monthly_adjusted_close.iloc[12*(i+1)] - monthly_adjusted_close.iloc[12*(i)])/monthly_adjusted_close.iloc[12*(i)])
        returns_array.append(returns)
    return returns_array    

def mean_returns(returns_array):
    means = []
    for i in range(len(returns_array)):
        means.append(np.mean(returns_array[i]))
    return means
    
def expected_return_portfolio(mean_returns, weights):
    sum_weights = 0
    for i in range(len(weights)):
        sum_weights = sum_weights + weights[i]
    if (len(mean_returns) == len(weights) and np.isclose(sum_weights, 1)):
        u=0
        for i in range(len(mean_returns)):
            u = u + mean_returns[i]*weights[i]
        return u 
    else:
        raise ValueError("Dimensions are unequal or weights don't sum to 1")

def covariance_returns_x_y(returns_x, returns_y):
    n = len(returns_x)
    if len(returns_y) == n:
        mean_xy = 0
        for i in range(n):
            mean_xy = mean_xy + returns_x[i]*returns_y[i]/n
        covariance = mean_xy - np.mean(returns_x)*np.mean(returns_y)
        return covariance
    else:
        raise ValueError("Dimensions are unequal")
    
def covariance_returns_matrix(returns_array):
    n = len(individual_returns)
    covariance_returns_matrix = np.zeros((n,n))
    for i in range(n):
        for j in range(n):
            covariance_returns_matrix[i,j] = covariance_returns_x_y(individual_returns[i], individual_returns[j])
    return covariance_returns_matrix

def risk_portfolio(covariance_returns_matrix, weights):
    sum_weights = 0
    for i in range(len(weights)):
        sum_weights = sum_weights + weights[i]
    dim = np.shape(covariance_returns_matrix)
    m = dim[0]
    n = dim[1]
    if (m == n and np.isclose(sum_weights, 1)):
        covariance = 0
        for i in range(m):
            for j in range(n):
                           covariance = covariance + weights[i]*weights[j]*(covariance_returns_matrix[i][j])
        return covariance**0.5
    else:
        raise ValueError("Dimensions are unequal or weights don't sum to 1")
        
def draw_mpt_graph(expecteds_return_portfolio, risks_portfolio):
    if len(expecteds_return_portfolio) == len(risks_portfolio):
        x = expecteds_return_portfolio
        y = risks_portfolio
        plt.plot(x,y, "b-", label='Efficient Frontier')
        plt.xlabel('Expected Return')
        plt.ylabel('Risk (Standard Deviation)')
        plt.title('Mean-Variance Optimisation (Efficient Frontier)')
        plt.legend()
        plt.grid(True)
        plt.show()
    else:
        print("dimensions are unequal")

def maximising_return_weights(mean_returns):
    sum = np.sum(mean_returns)
    if sum == 0:
        return mean_returns
    return mean_returns/sum
    
individual_returns = create_returns_list(['AAPL', 'MSFT', 'AMZN', 'TSLA', 'GOOGL', 'GOOG'])
mean_individual_returns = mean_returns(individual_returns)

covariance_returns_matrix = covariance_returns_matrix(individual_returns)

expecteds_return_portfolio = []
risks_portfolio = []
for i in range(100000):
    weights_array_i = []
    sum = 0
    for j in range(5):
        weight = random.rand()
        weights_array_i.append(weight)
        sum += weight
    weights_array_i.append(1 - sum)
    expected_return = expected_return_portfolio(mean_individual_returns, weights_array_i)
    risk = risk_portfolio(covariance_returns_matrix, weights_array_i)
    expecteds_return_portfolio.append(expected_return)
    risks_portfolio.append(risk)
draw_mpt_graph(expecteds_return_portfolio, risks_portfolio)
